<!DOCTYPE HTML>

<html>

<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>SLACjs Test</title>

	<style>
		#slac-stage canvas {
			border: 1px solid black;
			background-color: #eeeeee;
			box-sizing:border-box;
			-moz-box-sizing:border-box;
			-webkit-box-sizing:border-box;
		}
	</style>
</head>

<body>


<h1>SLAC.js <small>(ES6 Version)</small></h1>
<p>Current average error: <span class="landmark-error"></span></p>

<div id="slac-stage">
	<canvas id="slacjs-map" height="600" width="600"></canvas>
</div>

<p class="landmark-individual-error"></p>
<p class="error-output"></p>

<textarea rows="4" cols="50" class="error-csv"></textarea>

<script type="text/javascript" src="assets/js/browser-polyfill.js"></script>
<script type="text/javascript" src="vendor/vendor.js"></script>
<script type="text/javascript" src="assets/js/slacjs-app.js"></script>

<script type="text/javascript">
var conditions = [1, 2, 5, 10, 25, 50, 100];
var maxSimulations = 500;
var currentSimulation = 0;
var currentCondition = 0;
var errors = {};
var beacons = 7;

var timeBetweenSimulations = 0;

var errorsPerLandmark = {};

var step = function() {
	var success = SlacApp.step();

	if (!success) {
		SlacApp.reset();

		if(errors[currentCondition] === undefined) {
			errors[currentCondition] = [];
		}

		errors[currentCondition].push(SlacApp.error);
		SlacApp.error = {};

		startSimulation();
	}
	else {
		if (timeBetweenSimulations > 0) {
			setTimeout(step, timeBetweenSimulations);
		}
		else {
			step();
		}
	}
}

/*function parseErrors(error) {
	for (var key in error) {
		if (error.hasOwnProperty(key)) {
			if (errorsPerLandmark[key] === undefined) {
				errorsPerLandmark[key] = [error[key]];
			}
			else {
				errorsPerLandmark[key].push(error[key]);
			}
		}
	}
}

function printErrors() {
	var totalOutput = '';

	for(var key in errorsPerLandmark) {
		if(errorsPerLandmark.hasOwnProperty(key)) {

			var output = 'error' + key + ' = np.array([';

			errorsPerLandmark[key].forEach(function(e, i) {

				if(i == (errorsPerLandmark[key].length - 1)) {
					output += e;
				}
				else {
					output += e + ', '
				}
			});
			output += ']);<br>';

			totalOutput += output;
		}
	}

	$('.error-output').html(totalOutput);
}
*/

function outputToCsv() {

	var csv = '';

	conditions.forEach(function(c, i) {
		errors[i].forEach(function(e) {
			var output = c;

			for(var b = 1; b <= beacons; b++) {
				if(e[b] === undefined) {
					output += ';';
				}
				else {
					output += (';' + e[b].toFixed(4))
				}
			}

			csv += output + '\n';
		});
	});

	$('.error-csv').val(csv);
}

function startSimulation() {
	currentSimulation++;

	if(currentSimulation > maxSimulations) {

		//Start the new condition
		currentCondition++;
		startCondition();
		return;
	}

	SlacApp.initialize();

	setTimeout(step, 20);
}

function startCondition() {

	console.log(currentCondition);
	if(currentCondition >= conditions.length) {
		outputToCsv();
		return;
	}

	SlacApp.broadcastsPerStep = conditions[currentCondition];

	currentSimulation = 0;
	startSimulation();
}

startCondition();

</script>
</body>
</html>
